@page "/"

@using System.Diagnostics
@using HashWorkerBlazor.DB
@using HashWorkerBlazor.Models
@using System.Text
@using System.Text.Json
@using System.Text.Encodings.Web
@using System.Security.Cryptography
@using static HashWorkerBlazor.Tools.EncryptHelper
@inject ISnackbar Snackbar
@inject IHashWorkerApi api
@inject AuthenticationStateProvider authenticationStateProvider

<PageTitle>Index</PageTitle>

<MudGrid>
    <MudItem xs="12" sm="6" md="6">
        <MudTextField @bind-Value="scanPath" Label="Path to Scan" Variant="Variant.Outlined"></MudTextField>        
    </MudItem>
</MudGrid>
<div class="p-1">
    <MudButton Disabled="@(isLoading_scan || isLoading_send)" Variant="Variant.Filled" StartIcon="@Icons.Custom.Uncategorized.Radioactive" Color="Color.Warning" OnClick="@ScanBtnClick">
        @if (isLoading_scan)
        {
            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
            <MudText Class="ms-2">Processing</MudText>
        }
        else
        {
            <MudText>Scan Folder🈲</MudText>
        }
    </MudButton>
    <MudButton Disabled="@(isLoading_scan || isLoading_send || itemList.Count()==0)" Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.Send" Color="Color.Primary" OnClick="@SendBtnClick">
        @if (isLoading_send)
        {
            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
            <MudText Class="ms-2">Processing</MudText>
        }
        else
        {
            <MudText>Send Hash</MudText>
        }
    </MudButton>
</div>

@if (string.IsNullOrWhiteSpace(scanPath) || !Directory.Exists(scanPath))
{
    <p><em>Invalid Path😒😒</em></p>
}
else if(itemList == null)
{
    <p><em>Loading...😘😘</em></p>
}
else
{
    <MudTable Items="@itemList" Dense="true" Hover="true" Bordered="false" Striped="true"
          RowsPerPage="10" Loading="@(isLoading_scan || isLoading_send)" LoadingProgressColor="Color.Info">
        <ToolBarContent>
            <MudText Typo="Typo.h6">Hash List in @scanPath
                @if (!string.IsNullOrWhiteSpace(scanResult))
                {
                    <MudChip Variant="Variant.Outlined" Color="Color.Success">@scanResult</MudChip>
                }
            </MudText>
        </ToolBarContent>
        <HeaderContent>
            <MudTh>No</MudTh>
            <MudTh>Hash</MudTh>
            <MudTh>FileName</MudTh>
            <MudTh>FilePath</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="No">@context.No</MudTd>
            <MudTd DataLabel="Hash">@context.Hash</MudTd>
            <MudTd DataLabel="FileName">@context.FileName</MudTd>
            <MudTd DataLabel="FilePath" HideSmall="true">@context.FilePath</MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
}

@code {
    private string scanPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
    private string scanResult = string.Empty;
    private List<HashContent> itemList = new List<HashContent>();
    private bool isLoading_scan = false;
    private bool isLoading_send = false;


    protected override async Task OnInitializedAsync()
    {
        //
        await base.OnInitializedAsync();
    }

    private async Task SendBtnClick()
    {
        if (itemList.Count==0)
        {
            Snackbar.Add("Empty list!", Severity.Error);
            return;
        }
        //
        isLoading_send = true;
        //
        await Task.Delay(1);
        //
        var json=JsonSerializer.Serialize<List<HashContent>>(itemList, new JsonSerializerOptions{ Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping});
        var account = (await authenticationStateProvider.GetAuthenticationStateAsync()).User.Identity?.Name ?? string.Empty;
        var result = await api.SendListAsync(account, scanPath, json, SHA1Encrypt.genStrHash(json), itemList.Count());
        //
        Snackbar.Add(result.msg, result.isOk ? Severity.Warning : Severity.Error);
        //
        isLoading_send = false;
    }

    private async Task ScanBtnClick()
    {
        if (!Directory.Exists(scanPath))
        {
            Snackbar.Add(scanResult = "Non-valid folder path!", Severity.Error);
            return;
        }
        //
        scanResult = string.Empty;
        itemList.Clear();
        isLoading_scan = true;
        //
        await Task.Delay(1);
        //
        Stopwatch sw = new Stopwatch();
        //
        //method 1: calc hash after the whole select run and use parallel func.
        sw.Start();
        itemList = new DirectoryInfo(scanPath)
                    .GetFiles("*", SearchOption.AllDirectories)
                    .Select((fileInfo, idx) => new HashContent
                        {
                            No = idx + 1,                
                            FileName = fileInfo.Name,
                            FilePath = fileInfo.FullName
                        })
                    .ToList();
        Parallel.ForEach(itemList, item => {
            try
            {
                //item.Hash = BitConverter.ToString(SHA1.Create().ComputeHash(File.OpenRead(item.FilePath))).Replace("-", "");
                item.Hash = SHA1Encrypt.genFileHash(item.FilePath);
            }
            catch (Exception ex)
            {
                item.Hash = $"err msg:{ex.Message}";
            }
            item.FilePath = $"~{item.FilePath.Substring(scanPath.Length)}";
        });
        sw.Stop();
        Snackbar.Add(scanResult = $"{itemList.Count():N0} rows updated in {sw.Elapsed.TotalSeconds:N2}s!", Severity.Warning);

        //
        isLoading_scan = false;

        //method 2: calc hash in each select run
        //sw.Restart();
        //using (SHA1 sha1 = SHA1.Create())
        //{
        //    itemList = new DirectoryInfo(scanPath)
        //    .GetFiles("*", SearchOption.AllDirectories)
        //    .Select((fileInfo, idx) => new HashContent
        //        {
        //            No = idx + 1,
        //            Hash = BitConverter.ToString(sha1.ComputeHash(fileInfo.OpenRead())).Replace("-", ""),
        //            FileName = fileInfo.Name,
        //            FilePath = $"~{fileInfo.FullName.Substring(scanPath.Length)}"
        //        })
        //    .ToList();
        //}
        //sw.Stop();
        //Snackbar.Add($"{itemList.Count()} rows updated! in {sw.Elapsed.TotalSeconds}s", Severity.Warning);


        //method 3: calc hash in each select run with async/await, then whenAll waiting
        //sw.Restart();
        //itemList = (await Task.WhenAll<HashContent>(
        //                    new DirectoryInfo(scanPath)
        //                        .GetFiles("*", SearchOption.AllDirectories)
        //                        .Select(async (fileInfo, idx) => new HashContent
        //                            {
        //                                No = idx + 1,
        //                                Hash = BitConverter.ToString(await SHA1.Create().ComputeHashAsync(fileInfo.OpenRead())).Replace("-", ""),
        //                                FileName = fileInfo.Name,
        //                                FilePath = $"~{fileInfo.FullName.Substring(scanPath.Length)}"
        //                            })
        //                    )
        //            ).ToList();
        //sw.Stop();
        //Snackbar.Add($"{itemList.Count()} rows updated! in {sw.Elapsed.TotalSeconds}s", Severity.Warning);
    }


    

}